# Data structure

---

## 배열, 연결리스트 예상 문제

**1. Array 와 LinkedList 의 차이가 무엇인가요 (naver 전화 면접)**
    
        
        Array 는 Random Access를 지원한다. 요소들을 인덱스를 통해 직접 접근할 수 있다. 따라서 특정 요소에 접근하는 시간복잡도는 O(1)이다.
        Linkedlist는 Sequential Access를 지원한다. 어떤 요소를 접근할 때 순차적으로 검색하며 찾아야 한다. 따라서 특정 요소에 접근할 때 시간복잡도는 O(N)이다.
        
        저장방식도 배열에서 요소들은 인접한 메모리 위치에 연이어 저장된다. 반면 Linkedlist에서는 새로운 요소에 할당된 메모리 위치 주소가 linkedlist의 이전 요소에 저장된다.
        
        저장방식도 배열에서 요소들은 인접한 메모리 위치에 연이어 저장된다.
        
        Linkedlist에서는 새로운 요소에 할당된 메모리 위치 주소가 linkedlist의 이전 요소에 저장된다.배열에서 삽입과 삭제는 O(N)이 소요되지만, Linkedlist에서 삽입과 삭제는 O(1)이 소요된다.
        
        배열에서 메모리는 선언 시 컴파일 타임에 할당이 된다.(정적 메모리 할당) 반면 Linkedlist에서는 새로운 요소가 추가될 때 런타임에 메모리를 할당한다.(동적 메모리 할당)
        
        배열은 Stack 섹션에 메모리 할당이 이루어 진다. 반면 Linkedlist는 Heap 섹션에 메모리 할당이 이루어진다.
<BR>
        
**2. 미리 예상한 것보다 더 많은 수의 data를 저장하느라 Array의 size를 넘어서게 됐다. 어떻게 해결할 수 있을까?**
    
        1. 기존의 size보다 더 큰 Array를 선언해 데이터를 옮겨 할당합니다. 모든 데이터를 옮긴 후에는 기존 Array는 메모리에서 삭제하면 됩니다.
        2. 다른 방법으로는, size를 예측하기 쉽지 않다면 Array 대신 Linked List를 사용함으로써 데이터가 추가될 때마다 메모리 공간을 할당받는 방식을 사용할 수 있습니다.

<BR>

**3. Array 와 Linked List 의 Memory Allocation 은 언제 일어나며, 메모리의 어느 영역을 할당받는가요?**

    
        
        배열은 컴파일 단계에서 스택 영역에 메모리를 할당 받고,
        링크드 리스트는 런타임 단계에서 새로운 노드를 추가할 때마다 힙 영역에 메모리 할당이 일어납니다.
<BR>

**4. List와 Set의 차이는 무엇인가요?**
    
       List는 중복된 데이터를 저장하고 들어온 순서를 유지하는 선형 자료구조이다.
       Set은 중복되지 않은 데이터를 저장하고, 들어온 순서를 유지하지 않는 선형 자료구조입니다.


## 스택, 큐 예상문제
**1. Stack과 Queue의 차이점은 무엇인가요? (N사 전화면접)**

        스택은 쌓아 올리는 자료구조이다. 같은 구조와 크기의 자료를 정해진 방향으로 쌓을 수 있고, 한 방향으로만 접근할 수 있다. top을 통해서 push, pop을 하면서 삽입과 삭제가 일어난다. 후입선출 구조이다. DFS나 재귀에서 사용된다.

        큐는 원소의 줄을 세우는 자료구조이다. 큐는 한 쪽 끝에서 삽입 작업을, 다른 쪽 끝에서 삭제 작업을 진행한다. 선입선출 구조이다. 주로 데이터가 입력된 시간 순서대로 처리되어야 하는 경우 사용한다. BFS나 캐시를 구현할 때 사용한다.
<BR>

**2. Stack과 Queue의 실생활 예시에는 어떤 것이 있을까요?**

        스택은 후입선출 구조이므로 웹 브라우저 방문기록, 실행취소(undo), 역순 문자열 만들기, 후위 표기법 계산에 사용됩니다.
        큐는 선입선출 구조이므로 프린터의 출력처리, 콜센터 고객 대기 시간, 너비 우선 탐색, 캐시(Cache) 구현에 사용됩니다.
<BR>

**3. Stack과 Queue의 두 가지 특성을 전부 사용하고 싶을 때는 무엇을 사용하면 좋을까요?**
        
        덱 Deque을 사용하면 됩니다.
        덱은 큐의 양쪽 끝에서 데이터의 삽입과 삭제가 모두 가능하게 만든 자료구조로, 스택과 큐의 성질을 모두 가지고 있습니다.

<BR>

**4. 스택으로 큐를 구현하는 방법과 큐로 스택을 구현하는 방법에 대해 설명해주세요**
        
        1. 스택으로 큐 구현하기
        
        스택 2개를 활용해서 구현할 수 있습니다.
        스택 A와 B가 있을 때, 큐에 PUSH연산이 일어나면 스택 A에 PUSH 합니다. 
        이후 큐에 POP연산을 한다면 스택A의 모든 데이터를 스택 B로 옮깁니다. 그렇게 되면 스택 A의 역순으로 데이터가 저장될 것이고, 스택 B를 POP하면 큐에 저장된 데이터 순서대로 출력될 것입니다.
        즉, 스택 A는 인큐의 역할, 스택 B는 디큐의 역할을 하게 됩니다.
        PUSH를 하면 스택 A에 가장 늦게 들어온 데이터가 맨 위에 쌓일 것이고, 이를 다시 스택 B로 옮기면 큐의 구조(선입선출)로 저장됩니다.
<BR>

        2. 큐로 스택 구현하기

        큐 2개를 활용해서 구현할 수 있습니다.
        큐 A와 B가 있을 때, 스택에 PUSH 연산이 일어나면, 해당 요소를 우선 큐 A에 PUSH 합니다.
        그 다음 마지막 원소(방금 PUSH한 요소)를 제외한 나머지를 큐 B에 옮긴 후, 다시 큐 A에 차례대로 PUSH한다.
        그럼 가장 나중에 들어온 값이 큐의 첫 번째 위치로 이동하게 되고, TOP이나 POP 연산이 일어날 경우 순서에 맞게 데이터를 POP할 수 있다. 
        
<BR>

## 우선순위 큐, 힙 예상문제

**1. 우선순위 큐란 무엇인가요?**
    
       우선순위 큐는 들어간 순서에 상관없이 우선순위가 높은 데이터를 먼저 꺼내기 위해 고안된 자료구조입니다.
       우선순위 큐 구현 방식에는 배열, 연결 리스트, 힙이 있고, 그중 힙 방식이 worst case라도 시간 복잡도 O(logN)을 보장하기 때문에 일반적으로 완전 이진트리 형태의 힙을 이용해 구현합니다.
<BR>

**2. 우선순위 큐의 동작원리가 어떻게 되나요? (N사 전화면접)**
    
        우선순위큐는 가장 우선순위가 높은 데이터를 먼저 꺼내기 위해 고안된 자료구조입니다.
        우선순위 큐를 구현하기 위해서 일반적으로 힙을 사용합니다. 
        힙은 완전이진트리를 통해서 구현되었기 때문에 우선순위 큐의 시간복잡도는 O(logn)입니다.
        우선순위 큐는 힙이라는 자료구조를 가지고 구현한다. top이 최대면 최대힙, top이 최소면 최소힙으로 표현한다. 
        힙으로 구현된 이진 트리는 모든 정점이 자신의 자식 요소보다 우선순위가 높다는 성질을 가지고 있다. 
        이 성질을 통해 삽입과 삭제 연산을 모두 O(logN)으로 수행할 수 있다.
<BR>

**3. 자료구조 힙의 특징을 설명해주세요**
    
        우선 순위가 높은 요소가 먼저 나가는 특징을 가진다.
        루트가 가장 큰 값이 되는 최대 힙과 루트가 가장 작은 값이 되는 최소 힙이 있다.

<BR>


## 해시 예상문제
**1. 해시 태이블에 대해 설명해보세요.**
        
        해시 테이블(Hash Table)은 해시 함수를 사용하여 데이터를 저장하고 검색하는 자료구조입니다. 이는 효율적인 검색 속도를 제공하며, 평균적으로 상수 시간(O(1))에 데이터를 찾을 수 있습니다. 해시 테이블은 배열을 기반으로 하며, 배열의 각 원소는 "버킷"이라 불리는 위치를 나타냅니다.


        해시 함수를 통한 해시 코드 계산을 통해 데이터를 효율적으로 찾고 저장할 수 있어서 평균적으로 O(1)의 시간 복잡도를 가집니다.

        상대적으로 적은 메모리를 사용하면서도 높은 성능을 제공합니다. 다만 충돌(Collision)이 발생할 경우에 대한 처리가 필요합니다.

        두 개 이상의 데이터가 동일한 버킷에 할당될 때 충돌이 발생합니다. 이를 해결하기 위해 체이닝(Chaining)이나 개방 주소법(Open Addressing)과 같은 기법을 사용하여 충돌을 해결합니다.

        해시 테이블은 검색이 많이 요구되는 경우나 데이터를 신속하게 삽입/삭제해야 하는 경우에 매우 유용한 자료구조입니다.
<BR>

**2. 해시함수에 대해 설명해보세요.**
        
        해시 함수(Hash Function)는 임의의 크기의 데이터를 고정된 크기의 해시 코드(해시 값)로 변환하는 함수입니다. 이러한 함수는 다양한 응용 분야에서 사용되며, 주로 데이터의 무결성을 유지하고 빠른 검색을 위해 활용됩니다. 
<BR>

**3. 해시 테이블을 사용했던 경험을 말해보세요.**
        
        제 경험은 [특정] 프로젝트에서 데이터를 효율적으로 관리하기 위해 해시 테이블을 사용한 경우에 관한 것입니다. 이 프로젝트는 사용자 정보를 저장하고 검색하는데 중점을 두었습니다.
        사용자 정보를 신속하게 검색하고 업데이트하는 시스템을 개발했습니다.
        사용자 ID를 해시 함수를 통해 버킷으로 매핑하여 각 사용자의 정보를 효율적으로 저장했습니다. 사용자 ID를 해시화함으로써 빠른 검색 속도를 얻을 수 있었으며, 충돌이 발생할 경우에는 체이닝을 통해 충돌을 처리했습니다.
<BR>

**4. 해시테이블의 시간복잡도와 그 이유를 설명해주세요.**
        
        해시 테이블의 주요 연산인 검색(Search), 삽입(Insertion), 삭제(Deletion)에 대한 시간 복잡도는 일반적으로 O(1)이라고 말할 수 있습니다. 하지만 이는 최선의 경우이며, 충돌(Collision)이 발생하지 않는 경우를 가정한 것입니다. 충돌이 발생하는 경우, 충돌을 처리하는 방법에 따라 시간 복잡도가 더 복잡해집니다.
<BR>

**5. 해시의 사용 예시를 말해보세요.**
        
        해시 테이블을 이용한 데이터 검색, 암호화, 데이터 무결성 검사, 캐싱, 분산 시스템에서의 키 매핑, 블록체인
<BR>

## 트라이 예상문제
**1. 트라이에 대해 설명해보세요.**
        
        트라이는 검색트리의 일종으로, 키가 문자열인 동적 배열 또는 연관 배열을 저장하는데 사용되는 정렬된 트리 자료구조입니다.
        트라이의 주요 메서드는 insert, search, startswith입니다.
        insert는 입력받은 문자열을 한글자씩 체크하여 해당 노드의 children 딕셔너리에 키값으로 존재하지 않으면 키값으로 할당하고 새로운 노드를 만들어나가는 방식입니다. 이때 문자가 끝나는 지점의 노드는 bool word 값을 True로 설정해줍니다.
        search는 문자 한글자씩 탐색하다 중간에 키 값이 존재하지 않을시 False를 리턴하고, 문자가 끝났을 시에 노드의 word값이 False로 설정되어 있으면 False를 반환합니다.

<BR>

**2. 검색어 자동완성 시스템을 만들고자 할때 사용할 자료구조와 그 이유를 설명해보세요.**
        
        트라이 자료구조를 사용할 것입니다. 트라이는 문자열 검색에 특화된 자료구조로, 검색어를 저장하고 빠르게 검색하는 데 효과적입니다. 검색어의 접두사가 서로 공유될 수 있는 경우에 유용하며, 자동완성 시스템에서는 사용자가 입력한 부분 문자열과 일치하는 검색어를 빠르게 찾을 수 있습니다.
<BR>

## 그래프 예상 문제

**1. 그래프 탐색 방법인 BFS, DFS 의 시간복잡도는 뭘까요? (정점의 개수는 V, 간선 개수는 E 라 할게욤)**
    
        O(V+E)
<BR>

**2. 그래프를 구현하는 방법들을 설명해주세요**
        
        - 인접 행렬
          
        - 인접 리스트


## 트리 예상 문제

**1. 다른 이진 탐색 트리 알고리즘들과 비교했을 때, 레드 블랙 트리는 어떤 장점이 있나요?**

        - Worst Case에서도 O(logN)의 탐색 시간으로 탐색하기 위해서는 자가 균형 이진 트리가 필요합니다. 자가 균형 이진 트리의 종류는 대표적으로 레드블랙 트리, AVL 트리가 있습니다.
  
        - AVL 트리는 레드블랙 트리보다 더 엄격하게 균형이 잡혀있기 때문에, 삽입과 삭제를 할 때 최악의 경우 더 많은 회전(rotation)을 필요로 합니다. 레드 블랙 트리는 실 사용에 효율적이고, 최악의 경우에도 우수한 실행 시간을 보입니다.  n개의 노드가 있을 때 O(logN)의 시간복잡도로 삽입, 삭제, 검색을 할 수 있는 장점이 있습니다. 
<BR>

**2. BST 와 Binary Tree 에 대해서 설명해 주세요**

    
        
### Binary Tree (이진 트리)

   - **공통점:**
     - 모든 노드는 최대 두 개의 자식 노드를 가질 수 있습니다.
     - 각 노드는 부모와 자식 관계를 가지며, 트리의 맨 위에 있는 노드는 루트라고 불립니다.
     - 각 노드는 왼쪽 서브 트리와 오른쪽 서브 트리로 나누어집니다.

   ### Binary Search Tree (이진 탐색 트리)

   - **차이점:**
     - 각 노드의 왼쪽 서브 트리에 있는 노드들은 해당 노드보다 작은 값을 가지며, 오른쪽 서브 트리에 있는 노드들은 해당 노드보다 큰 값을 가집니다.
     - 이진 탐색 트리에서 특정 값을 찾을 때, 이 규칙을 활용하여 효율적으로 탐색할 수 있습니다.
     - 이진 탐색 트리는 정렬된 데이터를 삽입하면 자동으로 균형을 유지하도록 설계될 수 있습니다.

   ### 비교:

   | 특성                   | Binary Tree                    | Binary Search Tree              |
   |------------------------|--------------------------------|----------------------------------|
   | 자식 노드 개수          | 최대 2개                        | 최대 2개                          |
   | 노드 값 제약 조건       | 제한 없음                       | 왼쪽 서브 트리 < 현재 노드 < 오른쪽 서브 트리 |
   | 탐색 효율성            | 일반적으로 낮음                 | 높음 (균형이 잘 유지되면)       |
   | 데이터 정렬            | X                              | 정렬된 데이터를 삽입하면 자동 정렬 유지 가능 |



**3. 이 그래프 preorder, inorder, postorder 로 순회하는 순서 적어보세요**

<img width="562" alt="Untitled 1" src="https://github.com/42CSstudy/CS-Study/assets/87696004/fea5a7f6-443b-4bac-a89c-7aead89a98a5">

