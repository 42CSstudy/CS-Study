## 메모리 주소

![image (4)](https://github.com/42CSstudy/CS-Study/assets/69511382/1abeac76-8072-4f46-be56-799b7e1e41c6)


### 메모리 관리의 복잡성

- 메모리는 폰노이만 구조의 컴퓨터에서 유일한 작업 공간이며 모든 프로그램은 메모리에 올라와야 실행
- 일괄처리 시스템 : 한번에 하나 씩 실행함으로 관리 단순
- 시분할 시스템 : 모든 응용 프로그램이 메모리에 올라와 실행하기 떄문에 복잡운영체제도 프로그램이기 때문에 메모리에 올라와서 실행
    
![image (5)](https://github.com/42CSstudy/CS-Study/assets/69511382/5112e4df-0499-400f-ae2b-402080f49de5)

    

### 메모리 관리의 이중성

프로세스 : 메모리를 독차지 하려고함

메모리 관리자 : 메모리는 나누어 효율적 관리

### 언어 번역 프로그램의 종류

- 컴파일러 : 소스코드를 컴퓨터가 실행할 수 있는 기계어로 번역한 후 한꺼번에 실행(C언어, 자바 등)
- 인터프리터 : 소스코드를 한 행씩 번역하여 실행(js,베이직 등) - 에러 찾기가 어렵고 최적화 어려움

### 컴파일러의 목적

- 오류 발견
- 코드 최적화(속도 up)

### 컴ㅍㅏ일러와 인터프리터의 차이

![image (6)](https://github.com/42CSstudy/CS-Study/assets/69511382/7ff2e422-750f-4197-9958-da9a30e11b2d)


## 메모리 관리자

메모리 관리자(memory manage Unit, MMU) : 메모리를 관리를 담당하는 **하드웨어**

### 메모리 관리자의 작업

![image (7)](https://github.com/42CSstudy/CS-Study/assets/69511382/8e57f7be-96e3-48f7-9aef-75436c3b161c)


- 가져오기 작업 : 프로세스와 데이터를 메모리로 가져옴
- 배치 작업 : 가져온 프로세스와 데이터를 메모리의 어떤부분에 올려놓을지 결정
- 재배치 작업 : 꽉 차있는 메모리에 새로운 프로세스를 가져오기 위해 오래된 프로세스를 내보냄

### 메모리 관리자의 정책

- 가져오기 정책 : 프로세스가 필요로 하는 데이터를 언제 메모리로 가져올리 결정
- 배치 정책 : 가져온 프로세스를 메모리의 어떤 위치에 올려놓을지 결정
- 재배치 정책 : 메모리가 꽉 찼을 때 메모리 내에 있는 어떤 프로세스를 내보낼지 결정

## 32bit cpu와 64bit cpu 차이

### cpu의 비트

- 한번에 다룰 수 있는 데이터의 최대 크기 - word라고 부름
- 32bit cpu는 한번에 32bit까지 다룰수 있(1word = 32bit)
- 32bit cpu 레지스터 크기는 32bit, 산술 논리연산장치, 대역폭도 32bit

### 32bit cpu의 메모리 크기

- 2의 32승(약 4GB)

### 64bit cpu의 메모리 크기

- 2의 64승(거의 무한대의 가까운 메모리 사용)결론 : 메모리의 공간이 달라짐(차이)
    
![image (8)](https://github.com/42CSstudy/CS-Study/assets/69511382/fd2e4965-cf0d-4e3f-946b-aea1f343c2dc)

    

### 물리 주소 공간과 논리 주소 공간

- 물리주소공간 : 하드웨어 입장에서 바라본 주소 공간으로 컴퓨터마다 크기가 다름
- 논리주소공간 : 사용자 입장에서 바라본 주소 공간

## 절대주소와 상대주소

### 단순 메모리 구조

- 일괄 처리 시스템
- 메모리를 운영체제와 사용자 영역으로 나누어 관리
    
![image (9)](https://github.com/42CSstudy/CS-Study/assets/69511382/f150174a-a193-4a40-93e5-7cb6cbed84a9)

    

단순 메모리 구조에서 사용자 프로세스 적재

- 사용자 프로세스는 운영체제 영역을 피하여 메모리를 적재
- 사용자 프로세스가 운영체제의 크기에 따라 매번 적재되는 주소가 달라지는 것은 번거롭다.그래서 사용자 메모리의 최상위 부터 사용**주소변경이 복잡해 잘안씀**
    
![image (10)](https://github.com/42CSstudy/CS-Study/assets/69511382/245e1979-671a-4a2f-a1ca-02615c912cf8)

    

### 경제 레지스터

- 운영체제 영역과 사용자 영역 경제 지점의 주소를 가진 레지스터
- 사용자 영역과 운영체제영역의 침범을 막음
- 메모리 관리자는 사용자가 작업을 요청 할 때마다 경제 레지스터의 값을 벗어나는지를 검사,벗어나는 프로세스가 있다면 프로세스 종료

### 절대 주소(absolute address)

- 실제 물리 주소를 가르키는 주소
- 메모리 주소 레지스터가 사용하는 주소
- 컴퓨터에 꽂힌 램 메모리의 실제 주소

### 상대 주소(relative address)

- 사용자 영역이 사작되는 번지를 0번지로 변경하여 사용하는 주소
- 사용자 프로세스 입장에서 바라본 주소
- 절대 주소와 관계없이 항상 0번지 부터 시작
- 프로세스 입장에서 상대 주소가 사용할 수 없는 영역의 위치를 알 필요가 없고, 주소가 항상 0번지부터 시작하기 때문에 편리

### 절대 주소와 상대 주소의 차이

- 논리 주소 공간은 상대 주소를 사용하는 주소 공간
- 물리 주소 공간은 절대 주소를 사용하는 주소 공간
    
![image (11)](https://github.com/42CSstudy/CS-Study/assets/69511382/5ddc17c0-413a-431b-9a17-f64e3bd48dab)

    

### 상대 주소를 절대주소로 변환하는 과정

- 메모리 관리자는 사용자 프로세스가 상대주소를 사용하여 메모리에 접근할 때마다 상대 주소값에 재배치 레지스터 값을 더하여 절대 주소를 구함
- 재배치 레지스터는 주소변환의 기본이 되는 주소값을 가진 레지스터로 메모리에서 사용자 영역의 시작 주소값이 저장

## 메모리 오버레이

- 프로그램의 크기가 물리메모리보다 클면 프로그램을 짤라서 가져오는 기법
- 사용하면 물리 메모리보다 더 큰 프로그램 실행 가능

### 메모리 오버레이의 동작 방식

- 프로그램이 실행되면 필요한 모듈만 메모리에 올라와서 실행어떤 모듈을 가져오거나 내보낼지는 CPU레지스터 중 하나인 프로그램카운터(PC)가 결정프로그램 카운터는 앞으로 실행할 명령어의 위치를 가르키는 레지스터해당 모듈이 메모리에 없으면 메모리관리자에서 요청해 가져오게함
    
![image (12)](https://github.com/42CSstudy/CS-Study/assets/69511382/607d9aba-ee9b-46f6-bda2-8e6616a03fd7)

    

### 메모리 오버레이의 의미

- 한정된 메모리에서 메모리보다 큰 프로그램 실행 가능
- 프로그램 전체가 아니라 일부만 메모리에 올라와도 실행 가능

### 스왑

### 스왑영역(swap area)

- 메모리가 모자라서 쫒어난 프로세스를 저장장치의 특별한 공간에 모아두는 영역
- 메모리에서 쫒겨났다가 다시 돌아가는 데이터가 머무는 곳이기 때문에 저장장치는 장소만 빌려주고 메모리 관리자가 관리
- 사용자는 실제 메모리의 크기와 스왑 영역의 크기를 합쳐서 전체 메모리로 인식하고 사용

swap -> 메모리 = 스왑인

메모리 -> swap = 스왑아웃

## 다중 프로그래밍 환경에서의 메모리 할당

### 메모리 분할 방식

- 가변 분할 방식 : 프로세스의 크기에 따라 메모리를 나누는것
- 고정 분할 방식 : 프로세스의 크기와 상관없이 메모리를 같은 크기로 나누는 것

### 메모리 분할 방식의 구현

- 가변 분할 방식프로세스의 크기에 맞게 메모리가 분할메모리의 영역이 각각 다름연속 메모리 할당
- 고정 분할 방식프로세스의 크기에 상관없이 메모리가 같은 크기로 나뉨큰 프로세스가 메모리에 올라오면 여러 조각으로 나누어 배치비연속 메모리 할당
    
![image (13)](https://github.com/42CSstudy/CS-Study/assets/69511382/3a23f0fc-8eca-4909-a572-9e2bcf43bca6)

    

### 가변 분할 방식의 장단점

- 장점 : 프로세스를 한 덩어리로 처리하여 하나의 프로세스를 연속된 공간에 배치
- 단점 : 비어 있는 공간을 하나로 합쳐야 하며(외부 단편화), 이 과정에서 다른 프로세스의 자리고 옮겨야 하므로 **메모리 관리가 복잡함**
- 외부 단편화 :
    
![image (14)](https://github.com/42CSstudy/CS-Study/assets/69511382/6ad1fc91-32ff-4fff-9d42-f2b4711ae3f1)

    
- 외부 단편화 해결방법 :
1. 메모리 배치 방식- 작은 조간이 발생하지 않도록 프로세스 배치1 . 최초 배치:프로세스를 메모리의 빈공간에 배치할 때 메모리에서 적재 가능한 공간을 순 서대로 찾다가 첫 번째로 발견한 공간에 프로세스를 배치하는 방법2 . 최적 배치 : 모메리의 빈 공간을 모두 확인한 후 적당한 크기 가운데 가장 작은 공간에 프로세스를 배치하는 방법
    1. 최악 배치 : 빈 공간을 모두 확인한 후 가장 큰 공간에 프로세스를 배치하느ㅜㄴ 방법
2. 조각모음 : 조각이 발생 했을 때 작은 조각들을 모아서 하나의 큰 덩어리로 만드는 것

### 고정 분할 방식의 장단점

- 장점 : 메모리를 일정한 크기로 나누어 관리하기 때문에 메모리 관리가 수월(가변 분할 방식의 메모리 통합 같은 부가적인 작업을 할 필요가 없음)
- 단점 : 쓸모없는 공간으로 인해 메모리 낭비 발생(내부 단편화)