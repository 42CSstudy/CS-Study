# 📌 프로세스란?
**메모리에 적재되고 CPU 자원을 할당받아 실행 중인 프로그램**

운영체제에 의해 관리되며, 독립적으로 실행되고 자원을 할당받을 수 있는 **작업의 단위**

→ 디스크에 있는 프로그램이 메모리에 로드되면 프로세스가 된다

- 역할 : 프로세스들에게 적절히 자원을 분배해 여러가지 작업을 수행할 수 있도록  한다

![1](https://github.com/CS-Study-crew/2024-CS-Study/assets/83401978/ceccf7c2-af32-4ce4-9fcf-065566606b74)


## 구조

- 프로세스 실행 과정 : 코드의 데이터를 메모리에 올려 실행 → 프로세스마다 고유한 가상 메모리 공간 제공

![1](https://github.com/CS-Study-crew/2024-CS-Study/assets/83401978/55ec4c5a-0521-46cb-8e4d-4b0d2492c3bf)

**① code 영역(Text Segment)**

- 내가 작성한 **코드가 저장되는 공간** (코드는 컴파일 되어 0과 1로 변환된 기계어가 저장)

**② Data 영역(Data Segment)**

- 코드에서 선언된 **전역 변수, 정적 변수, 상수 등을 저장**한다.
- 초기화된 변수와 초기화되지 않은 변수들이 나눠서 저장된다.
- 데이터 영역은 프로그램의 시작 시 초기화되며, 프로세스가 종료될 때까지 유지된다.

**③ Stack**

- 내가 작성한 함수에서 **지역변수, 매개변수, return 주소들을 저장**한다.
- 프로세스마다 독립적인 stack을 가질 수 있고, stack 포인터를 통해 스택의 상태를 관리한다.
- 함수가 호출되면 stack 공간이 생성되며, 함수가 종료되면 제거된다.

**④ Heap**

- 코드에서 **동적으로 생성되는 데이터 구조나 객체들을 저장**한다.
- 프로세스의 주소 공간의 나머지 영역에 위치하며 데이터가 추가됨에 따라 **크기를 동적으로 확장**할 수 있다
    
![1](https://github.com/CS-Study-crew/2024-CS-Study/assets/83401978/653037b3-9b69-49ad-a55f-7ba65a0d3ed1)
    

---

## 프로세스 문맥

프로세스의 특정 시점의 상태를 표현하는 정보

- 하드웨어 문맥
    
    : 특정 하드웨어를 이용하여 해당 프로세스가 어디가지 실행되었는지 알 수 있다
    
    - 프로그램 카운터 Program Counter
    - 각종 레지스터 Register
- 프로세스의 주소 공간
- 프로세스 관련 커널 자료구조 PCB(Process Control Block)
- 프로세스 커널 스택

# 상태

5가지의 프로세스 상태 생명주기에 따라 프로그램을 처리한다

![1](https://github.com/CS-Study-crew/2024-CS-Study/assets/83401978/1064527c-d4ae-4c6a-9d02-f8b9c3290d6c)

1️⃣ **프로세스 생성 New**

프로세스가 **생성된 상태**

(생성만 되었고, 실행을 위한 자원을 할당받지 못한 상태)

2️⃣ **실행 가능 Ready**

프로세스가 **실행을 기다리는 상태**

(필요한 자원을 모두 할당받아 실행을 위한 준비가 완료된 상태 but CPU를 할당받지 못한 상태)

→ CPU를 할당받기 위해 스케줄링 대기열(Queue)에 들어간다

3️⃣ **실행 상태 Running**

프로세스가 CPU를 할당받아 실제로 코드를 실행하는 상태

→ 작업을 처리하고 결과를 만들어낸다

4️⃣ **대기 Waiting**

프로세스 처리 중에 작업시간이 초과되거나/자원 사용을 위해 대기해야하는 이벤트가 발생해서 **프로세스가 잠시 멈춘 상태** → CPU를 사용하지 않는다

→ 특정 자원을 사용할 수 있을 때까지 실행을 멈추고 다시 대기열 (Ready Queue)로 들어간다
 프로세스 처리 가능 상태가 되면 실행 Running 상태로 변경한다

5️⃣ **종료 Terminated, exit**

프로세스 실행이 완료되어 **종료된 상태**

→ 할당된 자원이 해제되고, 프로세스의 메모리 공간이 운영체제에 반환된다

![1](https://github.com/CS-Study-crew/2024-CS-Study/assets/83401978/dc8b90be-f75c-4ab3-b269-ae59388b366f)

시스템 구조 상에서의 process state

---

## PC와 SP

컴퓨터에서 프로세스를 처리하기 위한 2가지의 레지스터 - 프로세스의 실행 및 메모리 관리 역할

### PC(Program Counter)

**다음에 실행할 명령어의 주소**를 가리키는 레지스터

프로세스는 명령어를 순차적으로 실행하면서 PC값을 증가시켜서, PC가 다음에 실행한 명령어를 가리키도록 한다.

- 프로그램의 흐름을 제어하는 역할
    
    : 프로세스가 명령어를 실행하다 분기/점프 명령어를 만나면 PC 값을 분기된 주소로 변경하여 해당 명령어를 실행한다
    
- 프로세스 중단/인터럽트 발생 시 재실행시키는 역할
    
    : 프로세스 중단/인터럽트 발생 시 현재 실행 중인 명령어의 주소를 저장하고, 이후 다시 프로세스가 실행되었을 때 주소를 찾아 재실행 시킬 수 있다.
    

### SP(Stack Pointer)

**현재 실행 중인 프로세스의 스택 최상단**을 가리키는 레지스터

- 스택에 데이터를 저장하거나 불러올때 사용
    
    : 스택 프레임 Stack Frame(스택 공간)의 시작 주소를 가리킨다
    
    - 함수 호출 시
        
        : SP가 감소하여, 스택에 새로운 스택 프레임을 생성한다
        
    - 함수 반환 시
        
        : SP가 증가하여, 이전 스택 프레임으로 되돌아간다
        
- 프로세스의 스택 영역을 관리하고 스택 오버플로우 문제를 방지
    
    : 제한된 메모리 영역을 사용할 수 있도록 관리한다
    

# **PCB(Process Control Block)**

**프로세스 제어 블록**

운영체제가 각 프로세스를 관리하기 위해 **각 프로세스별로 보유하고 있는 자신의 정보 묶음**

└ 커널의 주소 공간에 위치한다

![2](https://github.com/CS-Study-crew/2024-CS-Study/assets/83401978/5dda4a04-b252-41be-97d9-fde690587d19)

![3](https://github.com/CS-Study-crew/2024-CS-Study/assets/83401978/ea49c904-920c-4e6d-9c7d-4f269b425a1a)


프로그램 실행 시 프로세스의 정보를 저장하는 별도의 공간이 생성된다

운영체제의 커널 Kernel도 하나의 프로그램이므로 프로세스처럼 정보를 저장할 수 있는 공간(stack, data, heap, …)이 생긴다. 이때 커널의 데이터Data 영역에서 각종 자원(프로세스의 상태, CPU 사용 정보, 메모리 사용 정보 등)을 관리하기 위해 PCB 공간을 둔다

➡️ PCB는 운영체제가 프로세스를 관리하기 위해 사용하는 데이터 구조

- 각 프로세스마다 유지되며 해당 프로세스의 상태 정보, 제어정보를 저장한다
    
    └ 프로세스가 생성되면 운영체제는 PCB를 할당 / 프로세스가 종료되면 해당 PCB를 해제
    

- 구성요소
    - 운영체제가 관리상 사용하는 정보
        - **프로세스 상태(Process State)**
            
            : 프로세스 스케줄링과 상호작용하여 프로세스의 실행을 관리한다
            
            - 프로세스의 현재 상태→ create, ready, running, waiting, terminated
                
                └ stack에 저장된다
                
            - 그 외의 상태 : 유예 준비상태 suspended ready, 유예 대기상태 suspended waiting
                
                └ disk에 저장된다
                
        - 프로세스 ID
        - 프로세스 우선순위
        - **스케줄링 정보(Scheduling Information)**
            
            : 프로세스의 우선순위, 할당 된 CPU 시간, 스케줄링 알고리즘과 관련된 정보 등 스케줄링에 필요한 정보를 포함한다.
            
    - CPU 수행 관련 하드웨어 값
        - **프로그램 카운터(Program Counter, PC)**
            
            : 프로세스가 다음에 실행할 명령어(코드)의 주소를 가리키는 포인터
            
        - **레지스터(Registers)**
            
            : 프로세스가 현재 실행되는 동안 사용되는 레지스터 값들
            
            → 프로세스가 일시 중단되고 다시 실행 될 때 레지스터 값들을 복원하는 데 사용
            
    - 메모리 관련
        
        Code, Data, Stack의 위치 정보, base/limit 레지스터 값
        
        - **메모리 관리 정보(Memory Management Information)**
            
            : 메모리 관리에 필요한 정보(프로세스가 사용하는 메모리 공간의 주소 범위, 페이지 테이블, 메모리 할당 정보 등)를 저장한다
            
    - 파일 관련
        
        open file descriptors : 열린 파일 목록
        
        - **입출력 상태(I/O state)**
        
        프로세스가 현재 사용 중인 입출력 장치와 관련된 정보를 포함한다. 예를 들어, 어떤 입출력 요청을 보내고 있는지, 어떤 파일을 열어두었는지 등의 정보를 저장한다.
        

- 존재 위치
    
    민감한 정보(식별자, 명령어, 상태, 다양한 메모리 주소 등)를 포함하고 있기 때문에 일반 사용자가 접근하기 어려운 보호된 메모리 영역에 남는다
    

## 문맥 교환 Context Switch

**프로세스가 실행되다가** 인터럽트가 발생해 **CPU를 다른 프로세스로 넘겨주는 과정**

현재 CPU를 사용중인 프로세스의 CPU 제어권이 다른 프로세스로 이양되는 과정

: 운영체제는 CPU를 제공하는 프로세스의 상태를 그 프로세스의 PCB에 저장하고, CPU를 새롭게 얻는 프로세스의 상태를 CPU에서 읽어온다

→ 즉 CPU 입장에서 Context는 PCB이기 때문에 문맥 교환이 일어나면 → PCB의 정보가 바뀌는 것

- 오버헤드 : 문맥 교환에 필요한 시간, 메모리 등

![1](https://github.com/CS-Study-crew/2024-CS-Study/assets/83401978/b4fbce53-f9a6-499a-baae-59589a2aaad3)

![2](https://github.com/CS-Study-crew/2024-CS-Study/assets/83401978/4fcfbf57-cef5-44b1-95e1-ecf299d6db56)

- 실행 시점
    - **멀티 태스킹**
        
        : 다수의 프로세스가 하나의 CPU자원을 나누어 사용하는 것
        
        실행 가능한 프로세스들이 운영체제 스케줄러에 의해 조금씩 CPU를 번갈아 할당받으며 수행됨 (CPU 할당 시 문맥 교환이 일어남)
        
        매우 빠른 속도로 처리되기 때문에 동시에 처리되는 것처럼 느껴진다
        
    - **인터럽트 처리**
        
        *인터럽트 : 컴퓨터 시스템에서 예외 상황이 발생했을 때, CPU에 알려 처리하도록 하는 상황
        
        : 인터럽트 발생 시 문맥 교환이 일어난다
        
    - **사용자 및 커널 모드 전환**
        
        : 운영체제에서 사용자 모드↔커널 모드 사이의 전환이 필요할 때, 운영체제에 따라 선택적으로 문맥 교환 발생
        

- 문맥 교환 과정
    
    ![3](https://github.com/CS-Study-crew/2024-CS-Study/assets/83401978/53d6fe97-a4c8-417b-9fe0-93c7a0a60661)
    
    1️⃣ 요청 발생 : 인터럽트/트랩에 의한 요청 발생 
                                           *트랩 : 소프트웨어 인터럽트
    
    2️⃣ PCB에 저장 : 운영체제가 현재 실행중인 프로세스(P0)의 정보를 PCB에 저장한다
    
    3️⃣ CPU 할당 : 다음 프로세스(P1)의 정보를 PCB에서 가져와 CPU를 할당한다
    

---

# 분류

- 동작하는 방식에 따라

1️⃣ **독립적 프로세스 Independent Process**

각자 주소 공간을 가지고 수행되며 원칙적으로 하나의 프로세스는 다른 프로세스 수행에 영향 X

2️⃣ **협력 프로세스 Cooperating Process**

프로세스 협력 메커니즘(IPC, Interprocess Communication)을 통해 하나의 프로세스가 다른 프로세스 수행에 영향을 미칠 수 있다

장점)

- 정보 공유
- 계산속도 향상
- 편리함

## 프로세스 협력 메커니즘 IPC : Interprocess Communication

![4](https://github.com/CS-Study-crew/2024-CS-Study/assets/83401978/9026dcc4-30bb-44fc-92e1-2ee219d98e90)

1. **공유 메모리 Shared Memory**
    
    서로 다른 프로세스 간에 일부 주소 공간을 공유하게 하는 방식
    
    - 장점) 커널을 거치지 않기 때문에 속도가 빠르다
    - 단점)여러 프로세스가 메모리에 동시에 접근하는 것을 방지하기 위해 별도의 구현이 필요하다.
2. **메세지 패싱 Message Passing**
    
    동일한 주소 공간을 공유하지 않고, 커널을 통해 메세지를 주고받는다
    
    └ 기본적으로 Send/Receive 작업을 통해 메세지를 교환한다
    
    - 장점) 커널이 기본 기능을 제공하기 때문에 공유 메모리 방식보다 구현이 쉽다
    - 단점) Context Switch가 발생하기 때문에 속도가 느리다
    
    - 전달 방식
        
        1) **Direct Communication**
        
        통신하려는 프로세스의 이름을 명시적으로 표시해야 한다
        
        ![5](https://github.com/CS-Study-crew/2024-CS-Study/assets/83401978/793a1b5a-60d9-4adc-8731-a2ebf0c6f6ac)
        
        통신하고자 하는 모든 프로세스 쌍들 사이에 자동으로 링크link가 생성된다 
        → 프로세스들은 서로의 이름만 알아도 통신이 가능하다
        
        - 링크 link : 오직 두 프로세스끼리만 관련되며, 주로 양방향이다. (단방향일 수 있다)
        
        단점)
        
        - 반드시 상대 프로세스의 이름을 알아야 한다
        - 제한된 모듈성을 가진다 → 어떤 프로세스의 이름을 변경한다면 연결되어있는 모든 Sender와 Receiver 프로세스를 바꿔야 한다
            - 모듈성 : 구성요소의 일부를 변경할 때 전체에 영향을 미치지 않도록 일부만 바꿀 수 있도록 설계되어 있는 것
        
        2) **Indirect Communication**
        
        mailbox를 통해 메세지를 전달한다
        
        ![6](https://github.com/CS-Study-crew/2024-CS-Study/assets/83401978/170deb37-90ed-4690-ab24-73c3fd084b2a)
        
        각각의 mailbox는 unique한 ID를 가지고 있다
        
        프로세스들은 서로 mailbox를 공유하고 있는 경우 링크가 생성되어 통신할 수 있다
        
        1)와 마찬가지로 양방향, 단방향 모두 가능하고, 하나의 링크가 셋 이상의 프로세스와 관련될 수 있다, (one-to-many, many-to-one, many-to-many)
        
    - 메세지 해싱의 동기화문제 해결 방법
        - **Blocking** - 동기식으로 간주
            - Blocking send : 수신자(프로세스/mailbox)가 메세지를 받을 때까지 발신자는 block
            - Blocking receive : 수신자가 메세지를 받을 때까지 block
        - **Non-blocking** - 비동기식으로 간주
            - Non-blocking send : 발신자가 메세지를 보내고 작업을 계속한다
            - Non-blocking receive : 수신자는 유효한 메세지 또는 null을 받는다
    
    - 메세지 저장 방법
        
        임시 큐 Temporary Queue에 프로세스 사이에서 교환되는 메세지들이 저장된다
        
        -임시 큐 구현 방법
        
        - Zero capacity (0 message) : 발신자는 반드시 수신자를 기다린다
        - Bounded capacity (finite length  of n message) : 링크가 꽉 찬다면 발신자는 기다린다
        - Unbounded capacity (infinite length) : 발신자는 기다리지 않는다

1. 파이프 pipe 방식 통신
    
    프로세스 사이에 파이프를 두고 정보를 주고 받는다
    
    - Anonymous 파이프 : 부모-자식 또는 공통의 부모를 갖는 프로세스끼리 통신이 가능하다
    - named 파이프 : 관계없이 사용할 수 있다
    
    - 특징
        - 파이프는 단방향 통신만 가능하다 (양방향 통신을 하려면 2개의 파이프 필요)
            
            └ 파이프 한쪽에선 데이터가 써지고, 한쪽 끝에선 데이터가 읽힌다 (큐와 비슷)
            
        - 파이프에 포함된 데이터의 크기나 수신자/발신자는 알 수 없다
        - 파이프로의 접근은 파일 서술자(File descriptor)를 통해 가능하다

---

# 프로세스 스케줄링

어떤 프로세스를 프로세서에 할당할 것인가 결정하는 것

큐를 통해 프로세스가 스케줄링 된다

- 필요성
    - 두 목적을 달성하기 위해 CPU에서 프로그램 실행을 위해 사용 가능한 프로세스를 선택한다
        - **멀티프로그래밍**의 목적 : CPU를 최대한 사용하기 위해 몇몇 프로세스를 항상 실행시키는 것
        - **시간 공유**의 목적 : 프로세스 간의 CPU를 빠르게 전환함으로써 사용자가 각 프로그램이 실행되는 동안 서로 상호작용할 수 있도록 만드는 것
    - 프로세서가 하나인 시스템은 오직 하나의 running 프로세스를 가질 수 있고, 
    여러 프로세스가 존재하는 경우 하나가 실행될 때, 나머지는 CPU가 free 상태가 될 때까지 기다려야 하기 때문에 적절한 프로세스 스케줄링이 필요하다.

- 큐의 종류
    
    ![7](https://github.com/CS-Study-crew/2024-CS-Study/assets/83401978/aa37991a-7a67-4872-8465-ae5a937374e3)
    
    - Job Queue 
    : 하드디스크에 있는 프로그램이 실행되기 위해 메인 메모리의 할당 순서를 기다리는 큐
    - Ready Queue
        
        : 현재 메모리 내에 존재하며 CPU를 잡아서 실행되기를 기다리는 프로세스의 집합
        
    - Device Queue
        
        : I/O 장치를 기다리는 프로세스의 집합
        

- 스케줄러의 종류
    - **Long-Term Schedular (장기 스케줄러/Job Schedular)**
        
        : 시작 프로세스 중 어떤 프로세스를 Ready Queue로 보낼지를 결정한다
        
        : 프로세스에 메모리 및 각종 자원을 할당한다
        
        : Degree of Multiprogramming(메모리에 몇 개의 프로세스가 존재하는지)를 제어한다
        
        (Time-sharing 시스템에는 보통 Long-Term Schedular가 존재하지 않고, 무조건 Ready Queue로 올라간다)
        
    - **Short-Term Schedular (단기 스케줄러/CPU Schedular)**
        
        : 어떤 프로세스를 다음에 실행시킬지를 선택한다
        
        : 프로세스에 CPU를 할당한다
        
    - **Medium-Term Schedular (중기 스케줄러/Swapper)**
        
        : 스와핑Swapping 작업을 수행한다
        
        - Swapping : 프로세스를 통째로 메모리에서 디스크로 쫓아내서 여유 공간을 마련하는 작업 (프로세스에게서 메모리를 뺏는다)
        
        : Degree of Multiprogramming(메모리에 몇 개의 프로세스가 존재하는지)를 제어한다
        
        : Suspended(Stopped) 상태를 추가적으로 나타낼 수 있다 - 외부적인 이유로 프로세스의 수행이 중지된 상태
        
        - Waiting : 자신이 요청한 이벤트가 만족되면 Ready 상태로 돌아간다
        - Suspended : 외부에서 다시 시작을 해주어야 활성화된다

![8](https://github.com/CS-Study-crew/2024-CS-Study/assets/83401978/6c76849f-4273-4d7c-a682-e2e1cdee8ccb)

프로세스 스케줄링을 반영한 프로세스의 상태표

---

# 프로세스 관리

- 프로세스 **생성** Process **Creation**
    - 생성 방식 : 부모 프로세스가 자식 프로세스를 생성하는 방식 → 트리(계층) 구조로 되어 있다
        
        
        - 프로세스 특징
            - 프로세스는 PCB에 저장된 pid(process identifier)값을 통해 식별되고 관리된다
            - 프로세스의 자원은 운영체제로부터 받거나, 부모와 공유한다
        
        - 프로세스 분류
            - 자원 공유 Resource sharing option
                - 부모-자식이 모든 자원을 공유하는 모델
                - 부모-자식이 자원의 일부를 공유하는 모델
                - 전혀 공유하지 않는 모델
            - 수행 Exeution
                - 부모와 자식이 공존하며 동시에 수행되는 모델
                - 자식이 종료될 때까지 부모가 기다리는 모델
            - 주소 공간 Address space
                - 자식이 부모의 공간을 복제하는 모델
                - 자식이 해당 공간에 새로운 프로그램을 올리는 모델
        
    
    ![9](https://github.com/CS-Study-crew/2024-CS-Study/assets/83401978/8da6bc22-29aa-4422-baa9-628e3ab3ec49)
    
    - `fork`
        
        부모를 그대로 복사하여 현재 프로세스와 pid만 다른 프로세스를 생성한다
        
        → 같은 동작을 하는 프로세스가 두 개 존재하게 되며, 새로운 프로세스는 원래의 프로세스 주소 공간의 복사본을 포함한다
        
        - 부모 프로세스와 자식 프로세스는 `fork()`의 반환 값으로 구분할 수 있다
            
            └ 부모 : `fork()`의 반환 값으로 0보다 큰 수(자식 프로세스의 pid) / 자식 : 0
            
        
        but `fork`는 heavy-weight한 시스템이다 (부모 프로세스의 전체 복사본을 생성하고, 이를 자식 프로세스로 실행시키기 때문에) → 이를 해결하기 위해 copy-on-write 기술을 사용한다
        
        - *copy-on-write*
            
            부모 프로세스가 fork하여 생긴 자식 프로세스의 page를 공유하다가, 자식이 page에 쓰기 작업을 할 때 해당 page만을 copy하는 방식이다 → 전체가 복사되는 현상 방지
            
            단점) 많은 양의 RAM이 사용되며, copy 시간이 오래 걸린다
            
        
        - `vfork`
            
            부모 프로세스의 복사본을 생성하지 않고, 부모-자식 사이에 데이터를 공유하는 방식
            
            → CPU 시간을 많이 줄일 수 있다
            
            자식 프로세스가 생성된 다음, 즉시 새로운 프로그램을 로드하기 위해 `exec()`을 호출해야 하는 상황을 위해 고안되었다
            but `fork`의 copy-on-write기술 사용으로 잘 사용되지 않는다
            
        
    - `exec`
        
        새로운 프로그램을 메모리에 올려 실행시킨다
        
        exec() 시스템 콜은 어떤 프로그램을 완전히 새로운 프로세스로 태어나도록 하는 역할
        
        프로세스는 exec() 시스템 콜을 통해 다른 프로그램을 수행할 수 있다
        
        → 기존에는 부모 프로세스를 그대로 복사한 상태지만, exec() 시스템 콜로 인해 다른 새 프로그램으로 덮어씌워진다
        
        ![10](https://github.com/CS-Study-crew/2024-CS-Study/assets/83401978/ba7c3b9a-914c-4339-bca1-d138e4aa80b2)
        
        fork 함수의 반환 값을 이용해서 만약 child일때 새로운 프로그램을 실행시키고 싶다면 exec() 시스템 콜을 사용하면 된다 (→ 이때 그 뒤의 명령어 /* CODE */ 부분은 수행하지 않는다)
        
    - `wait`
        
        만약 프로세스 A가 `wait()`을 호출하면 커널은 자식이 종료될 때까지 A를 Sleep(blocked) 시킨다. 그리고 자식 프로세스가 종료되면 커널이 A를 깨워 Ready 상태로 만든다
        
        (만약 자식이 먼저 수행되기를 원하면, 위 처럼 `wait()`를 else문에 넣어주면 된다)
        
- 프로세스 종료 Process Termination
    - 자발적 종료
        1. 현재 프로세스가 마지막 statement를 수행하면 운영체제에 `exit()` 명령어를 보내 이를 알려준다.
        2. 부모 프로세스가 현재 프로세스의 실행을 종료시키고, `wait`을 통해 자식으로부터 상태 값(status value)을 수집한다
        3. 프로세스의 각종 자원들은 운영체제에 반납된다
    - 비자발적 종료 (kill)
        
        부모 프로세스가 자식 프로세스의 수행을 종료시킨다
        
        └ 자식이 할당된 자원의 한계치를 넘어서거나 / 자식에게 할당된 작업이 더이상 필요하지 않거나 / 부모 프로세스가 종료되는 경우
        
        - 발생 가능한 문제 상황
            - Zombie process
                
                : 실행이 끝났지만 프로세스 테이블에 엔트리 Entry를 가지고 있는 (=정보가 메모리에 남아있는) 프로세스
                
                프로세스가 종료되었지만 버그/에러로 인해 해당 프로세스의 부모가 아직 `wait`을 통해 상태를 수집하지 못한 경우
                
                모든 프로세스는 아주 잠깐 좀비의 상태로 존재할 수 있다
                
            - Orphan process
                
                : 부모가 wait을 호출하지 않고 종료되었을 때의 자식 프로세스 → 부모는 종료되었지만 자식은 수행중인 경우
                
                → init process가 orphan process들의 새로운 부모로 할당되고, init process가 주기적으로 `wait`을 호출해서 orphan process들의 exit status를 수집한다
