# 가상 메모리 개요

### 가상 메모리란?

가상 메모리는 메모리 관리 기법 중 한가지로, 실제 메모리를 추상화 해 사용자들에게 실제 메모리보다 더 크게 보이도록 하는 기법이다.

가상으로 주어진 메모리의 주소를 **가상주소**라고 한다.

실제 메모리상에 있는 주소를 실제 주소 (physical address) 라고 한다.

이 가상주소는, 메모리 관리 장치(MMU) 에 의해 실제 주소로 변환되어 사용자는 실제 주소를 의식할 필요 없이 사용할 수 있다.

**용어**

메모리 관리 장치 (MMU) : 하드웨어 장치로, 가상 메모리와 물리 메모리 간 매핑을 관리한다. 프로세스가 메모리에 접근할 때 필요한 번역, 보안 기능을 제공한다. (주소 변환 가상→물리)

페이지 테이블 : 가상 주소와 실제 주소를 매핑하고, 프로세스의 주소 정보가 들어있다.

TLB : 메모리와 CPU 사이 일종의 캐시로, CPU 가 페이지 테이블에 직접 접근하지 않아도 주소 변환을 할 수 있도록 하여 속도를 향상시킨다.

<img width="580" alt="Untitled" src="https://github.com/42CSstudy/CS-Study/assets/87696004/c4ea6a81-9d86-4101-a5e2-020458eaac4f">

---

가상 메모리에는 존재하는 데이터인데, 실제 메모리 RAM 에는 현재 데이터가 없다면 **‘페이지 폴트’**가 발생한다.

이땐 메모리에서 사용하지 않는 영역을 하드디스크로 옮기고, 하드디스크에서 필요한 부분을 메모리로 불러와 사용하는데, 이를 **‘스와핑’** 이라고 한다.

페이지 폴트가 발생하지 않은 것처럼 만든다. 

페이지 폴트 : 프로세스의 주소 공간에는 존재하지만 지금 RAM 에는 없는 데이터에 접근했을 때 발생한다. 

가상 메모리가 결국 프로그램이 사용하는 주소 공간을 의미한다면, 프로세스의 주소 공간에 존재하는 데이터 말이 결국 가상 메모리에 존재하는 데이터 란 뜻

---

### 페이지 폴트와 스와핑 과정

1. CPU 는 물리 메모리를 확인하여, 해당하는 페이지가 없으면 **트랩**을 발생시켜 운영체제에 알린다.
2. 운영체제는 CPU 동작을 잠시 멈춘다.
3. 운영체제는 페이지 테이블을 확인해 가상 메모리에 페이지가 존재하는지 확인하고, 없으면 프로세스를 중단하고 현재 물리 메모리에 비어있는 프레임이 있는지 찾는다.
4. 비어있는 프레임에 해당 페이지를 로드하고, 페이지 테이블을 최신화 한다.
5. 중단되었던 CPU를 다시 시작한다.

- 페이지 : 가상 메모리를 사용하는 최소 크기 단위
- 프레임 : 실제 메모리를 사용하는 최소 크기 단위

---

### 스레싱

메모리의 페이지 폴트율이 높은것을 의미한다. 

스레싱은 메모리에 너무 많은 프로세스가 동시에 올라가 스와핑이 많이 일어나서 발생하게 된 것이다.

페이지 폴트가 일어나면 CPU 이용률이 낮아진다. (트랩 발생 시 운체가 cpu 동작을 멈추니까)

cpu 이용률이 낮아지면, 운영체제는 “cpu 가 한가한가?”라고 착각을하게 되어 가용성을 더 높이기 위해 더 많은 프로세스를 메모리에 올리게 된다.

프로세스가 많아질 수록 악순환이 반복되어 스레싱이 일어나게 된다.

### 스레싱 해결 방법

스레싱을 해결하기 위해서는 

1. 메모리를 늘려서 해결한다.
2. HDD 를 SSD 로 바꾼다.
3. 작업 세트
4. PFF 

의 방법이 있고, 운영체제 차원에서 해결할 수 있는 방법은 3 작업 세트 , 4 PFF 가 있다.

- 작업 세트 (working set)
    - 프로세스의 과거 사용 이력인 지역성 을 통해 결정된 페이지 집합을 만들어 미리 메모리에 로드하는 것.
    - 미리 메모리에 로드해 탐색에 드는 비용을 줄이고 스와핑 또한 줄일 수 있다.
    - 프로세스의 메모리 사용 패턴을 이해해 프로세스가 실제 얼마나 많은 메모리를 필요로 하는지 파악한다.
- PFF (Page Fault Frequency)
    - 페이지 폴트 빈도를 조절해 프로세스의 메모리 할당량을 조절한다.
    - 상한선과 하한선을 만드는 방법이다. 상한선에 도달하면 프레임을 늘이고, 하한선에 도달한다면 프레임을 줄이는 방식.

---

### 메모리 할당

메모리에 프로그램을 할당 할 땐 시작 메모리 위치, 메모리 할당 크기를 기반으로 할당하는데, 연속 할당과 불연속 할당으로 나눈다.

- **연속할당**
    - 메모리에 연속적으로 공간을 할당하는 것
    - 고정 분할 방식
        - 메모리를 미리 나누어 관리하는 방식으로, 융통성은 없고, 내부 단편화가 발생한다.
    - 가변 분할 방식
        - 매 시점 프로그램 크기에 맞게 동적으로 메모리를 나눠 사용한다.
        - 내부 단편화는 발생하지 않고 외부 단편화는 발생 가능하다.
        - 최초적합 : 위쪽이나 아래쪽부터 홀을 찾으면 바로 할당한다.
        - 최적적합 : 프로세스의 크기 이상인 공간 중 가장 작은 홀부터 할당한다.
        - 최악접합 : 프로세스의 크기와 가장 많이 차이나는 홀에 할당한다.

![Untitled 1](https://github.com/42CSstudy/CS-Study/assets/87696004/2c3ed299-1d77-4ef4-bf0c-ad652de5366c)

내부 단편화 : 메모리를 나눈 크기보다 프로그램이 작아서 들어가지 못하는 공간이 많이 발생하는 현상

외부 단편화 : 메모리를 나눈 크기보다 프로그램이 커서 들어가지 못하는 공간이 많이 발생하는 현상.

홀 : 할당할 수 있는 비어있는 메모리 공간

- **불연속 할당**
    - 메모리를 연속적으로 할당하지 않는 현대 운영체제가 쓰는 방법.
    - 페이징 기법
        - 동일한 크기의 페이지 단위로 나눠 메모리의 서로 다른 위치에 프로세스를 할당한다.
        - 홀 크기가 균일하지 않은 문제가 없어지지만 주소 변환이 복잡하다.
    - 세그멘테이션 기법
        - 페이지 단위가 아닌 의미 단위인 segment 로 나누는 방식이다.
        - 프로세스를 이루는 메모리는 코드, 데이터, 스택, 힙 영역으로 이뤄지는데 이를 세그먼트들로 나눈다.
        - 공유, 보안 측면에서 장점이 있지만 홀 크기가 균일하지 않다.
    - 페이지드 세그멘테이션
        - 프로그램을 의미 단위인 세그먼트로 나눠 공유, 보안 측면 강점을 가지고
        - 임의 길이가 아닌 동일 크기 페이지로 나누는 방법이다.
