# 📌 스레드란?
**프로세스 내부에서 실행되는 작은 작업 단위**

프로세스의 실행 흐름 구성 단위 → 하나의 프로세스 내부에 여러 개의 스레드가 포함될 수 있다

![1](https://github.com/42CSstudy/CS-Study/assets/83401978/4a28039b-7e8e-4a01-8635-1f41c149e576)

- 특징
    - 프로세스 데이터 영역에 접근이 가능하다 (프로세스 내부에 존재하기 때문에)
    - 스레드들끼리 서로의 데이터에 접근 가능하다
    - 작업을 병렬로 처리해서 처리 속도를 높일 수 있다
        
        (프로세스도 일종의 작업 단위이기 때문에 프로세스처럼 작업이 처리된다)
        
    - 일종의 함수로 구현된다 → 데이터를 다루고, 데이터를 관리하기 위해 stack 메모리 영역을 가진다 ➡️ **thread stack**
    - 하나의 프로세스 내부에 여러 개의 스레드를 가질 수 있다

- 장점
    - **응답성(성능) 향상**
        
        : 스레드 간의 작업 분할과 병렬 처리로 사용자가 응용 프로그램을 원활하게 사용하는 데 빠른 응답성(결과)를 제공할 수 있다.
        
    - **자원 공유 효율성 향상**
        
        : 하나의 프로세스 내에서 실행되기 때문에 -> 별도의 메모리 공간을 할당할 필요 없이, 프로세스의 자원을 공유해서 접근 가능하다
        
    - **동시성**
        
        : 여러 개의 스레드가 동시에 실행될 수 있어서, 작업을 병렬로 처리할 수 있다
        
    - **간결성**
        
        : 작업을 분리할 수 있어 코드가 간결해질 수 있다
        
- 단점
    - **스레드간의 상호간섭**
        
        : 멀티 스레드가 실행중일 때, 스레드간의 상호간섭 문제가 발생할 수 있다.
        
        스레드는 문제가 발생했을 때 (다른 스레드가 작업을 방해하거나, 스레드간의 우선순위 설정에 문제가 있을 경우) 서로에게 영향을 미치기 때문에 예상치 못한 이슈가 발생할 수 있다
        
    - **성능 저하**
        
        : 스레드를 많이 생성하면 성능 저하가 발생할 수 있다
        
        스레드를 많이 생성되면, 각각의 스레드들이 병렬로 실행되기 때문에 컨텍스트 스위칭이 빈번하게 발생하여 성능 저하가 발생할 수 있다
        
    - **동기화 이슈**
        
        : 여러 스레드가 공유 자원에 동시에 접근할 때, 동기화 문제가 발생할 수 있다
        
    - **자원 소비**
        
        : 스레드가 개별적인 실행 흐름을 가지기 때문에 스레드마다 메모리 자원을 소모한다
        
        → 스레드의 수가 증가하면 메모리 사용량도 증가한다
        

---
### 📌 **프로세스**와 **스레드**의 차이점

`프로세스`
운영체제는 프로세스마다 독립된 메모리 영역을 Code/Data/Stack/Heap의 형식으로 할당

➡️ 각각 독립된 메모리 영역을 할당해주기 때문에 **프로세스는 다른 프로세스의 변수나 자료에 접근할 수 없다.**

![2](https://github.com/42CSstudy/CS-Study/assets/83401978/bbb41944-372f-488f-b9c8-8c79045beea4)

`스레드`
스레드는 메모리를 서로 공유할 수 있다

프로세스가 할당받은 메모리 영역 내에서 Stack 형식으로 할당된 메모리 영역이 아닌, 나머지 **Code/Data/Heap 형식으로 할당된 메모리 영역을 공유**한다.

➡️ 스레드는 각각 별도의 스택을 가지고 있지만, **힙 메모리는 서로 읽고 쓸 수 있다**

![3](https://github.com/42CSstudy/CS-Study/assets/83401978/bb3701b8-861a-495e-bb3b-bdd1f4bc054b)


`프로세스` 운영체제로부터 별도의 메모리 영역을 할당받는다.

`스레드` Stack을 제외한 Code/Data/Heap 부분을 공유해 서로 읽고 쓸 수 있다
             (→ 공유 자원을 가진다)

---

- 유형
    
    멀티 스레드를 어느 영역에서 구현했는지
    
    - **커널 수준 스레드 (1:1 매핑 방식)**
        
        스레드를 OS(커널)이 직접 관리(스레드 생성, 스케줄링 등)한다
        
        ![4](https://github.com/42CSstudy/CS-Study/assets/83401978/2f5c81a8-fe26-4c22-aafd-33f68aade136)
        
        장점)
        
        - 커널이 각 스레드를 개별적으로 관리
        - 프로세스 내 스레드들이 병행 수행 가능
        - 하나의 스레드가 block되어도 다른 스레드는 계속 작업 가능
        
        단점)
        
        - 커널 영역에서 스레드의 생성 및 관리
        - 문맥 교환으로 인한 오버헤드가 큼
        - 사용자 스레드보다 생성 및 관리 속도가 느림
    
    - **사용자 수준 스레드 (N:1 매핑 방식)**
        
        사용자 영역의 스레드 라이브러리로 구현하며, 라이브러리는 스레드의 생성, 스케줄링을 담당한다
        
        - 커널은 스레드의 존재를 인식하지 못하기 때문에 커널의 개입을 받지 않는다
        
        ![5](https://github.com/42CSstudy/CS-Study/assets/83401978/8af85a39-d146-45f4-9649-28a83c618e60)
        
        장점)
        
        - 커널의 개입을 받지 않아 스레드의 생성 및 관리의 부하가 적음
        - 동일한 메모리 영역에서 스레드가 생성, 관리되므로 속도가 빠르다
        - 라이브러리를 통한 이식성이 높음
        
        단점)
        
        - 커널은 프로세스 단위로 자원을 할당하기 때문에 하나의 스레드가 block될 시 모든 스레드가 대기해야 함 (커널이 프로세스 내부 스레드를 인식하지 못해서 해당 프로세스를 대기 상태로 전환시키기 때문)
    - **혼합 스레드 (N:M 매핑 방식)**
        
        사용자 수준 스레드 + 커널 수준 스레드 혼합 구조
        
        일-대-일 방식과 다-대-일 방식의 문제점을 해결하기 위해 고안
        
        ![6](https://github.com/42CSstudy/CS-Study/assets/83401978/744e21d2-05d0-4321-b76b-683c7cb9d6b6)
        
        장점)
        
        - 프로세스 내 스레드들이 병행 수행 가능
        - 사용자는 원하는 수만큼 스레드 사용
        - 효율적이면서도 유연함
        - 스레드 풀링 기법을 통해 일-대-일 스레드 매핑에서의 오버헤드를 줄여줌
            - 스레드 풀링 : 시스템이 관리하는 스레드의 풀을 응용프로그램에 제공하여 스레들르 효율적으로 사용할 수 있게 하는 방법
                
                미리 생성한 스레드를 재사용하도록 하여 스레드 생성 시간을 줄기고 + 시스템 부하를 덜어줌 + 동시에 생성할 수 있는 스레드 수를 제한하여 시스템의 자원 소비를 줄임 + 해당 응용프로그램의 성능을 일정 수준으로 유지
                

## 멀티 프로세스

여러 개의 **독립적인 프로세스가 동시에** 실행되는 것

장점)

- 각 프로세스는 각각 고유한 자원을 관리하고 있어 서로에게 영향을 미치지 않는다
- 하나의 프로세스 작업을 여러 개로 분할(**스레드 단위**로)해서 병렬로 처리할 수 있다

단점)

- 각 프로세스는 독립된 메모리 공간을 가지기 때문에, 서로에게 접근하려면 IPC 기법을 사용해야 한다
- Context Switching 과정에서 캐쉬 메모리 초기화 등 무거운 작업이 진행되고 많은 시간이 소모되는 등의 오버헤드가 발생하게 된다.
- 프로세스는 각각의 독립된 메모리 영역을 할당받았기 때문에 프로세스 사이에서 공유하는 메모리가 없어, Context Switching가 발생하면 캐쉬에 있는 모든 데이터를 모두 리셋하고 다시 캐쉬 정보를 불러와야 한다.

## 멀티 스레드

**하나의 프로세스 내부**에서 **여러 개의 스레드가 동시에 실행**되는 것

장점)

- 스레드끼리 서로의 메모리 공간(thread stack)을 공유하고 접근할 수 있다 → 메모리 기반 통신이기에 통신 속도가 빠르다
- 공유하고 있는 메모리만큼 메모리 자원을 아낄 수 있다
- 프로세스 내에서 스레드의 작업을 여러 개로 분할해서 병렬로 처리할 수 있다 → 처리 속도를 높일 수 있다

단점)

- 각 스레드들은 여러 자원을 공유하기에, 하나의 스레드에 문제가 생기면 **나머지 스레드들도 영향**을 받을 수 있다
- 자원을 공유하기 때문에 필연적으로 **동기화 문제**가 발생할 수 밖에 없다
    - 동기화 문제 Synchronization Issue
        - 여러 스레드가 함께 전역 변수를 사용할 경우 발생할 수 있는 충돌
            
            ex. 만약 A 스레드가 어떤 자원을 사용하다가 B 스레드로 제어권이 넘어간 후 B 스레드가 해당 자원을 수정했을 때, 다시 제어권을 받은 A 가 해당 자원에 접근하지 못하거나, 바뀐 자원에 접근하게 되는 오류가 발생할 수 있다.
            

➡️ 멀티 프로세스 대신 멀티 스레드를 사용하는 이유

- 프로그램을 여러 개 키는 것보다 하나의 프로그램 안에서 여러 작업을 해결하는 것이 낫다
- 자원의 효율성 증대
    
    : 멀티 프로세스로 실행되는 작업을 멀티 스레드로 실행할 경우, 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리할 수 있다
    
- 처리 비용 감소 및 응답 시간 단축
    
    : 프로세스 간의 통신(IPC)보다 스레드 간의 통신의 비용이 적으므로 작업들 간의 통신 부담이 줄어든다
