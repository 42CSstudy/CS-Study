# 해시테이블 구현

## 🍀 해시테이블이란?

- 키를 값에 매핑할 수 있는 구조인 연관 배열 추상 자료형을 구현한 자료구조

![해시 테이블](HashTable1.png)

- C++ STL의 unordered_map, unordered_set, 그리고 여러 언어의 Dictionary나 HashMap, HashSet 등이 포함.
- 해싱: 해시 테이블을 인덱싱하기 위해 해시 함수를 사용하는 것
    - 성능 좋은 해시 함수의 특징
        - 해시 함수 값 충돌 최소화
        - 쉽고 빠른 연산
        - 해시 테이블 전체에 해시 값이 균일하게 분포
        - 사용할 키의 모든 정보를 이용해 해싱
- 해시 테이블은 충돌이 쉽게 일어나므로 **충돌을 최소화**하는 일이 중요
- 충돌은 대표적으로 Separate Chaining 혹은 Open Addressing 방식으로 해결한다.
- 로드 팩터가 증가할수록 해시 테이블의 성능은 점차 감소

### 해시 테이블의 장단점

- 장점: 시간 복잡도가 O(1)으로 데이터 양에 관계없이 빠른 성능.
- 단점: 충돌 가능성을 줄이기 위해 데이터 개수보다 큰 크기의 배열을 할당하여, 배열보다 상대적으로 메모리를 많이 사용

### 구현 (C)

```c
// 선언부
// 체이닝을 singly linked list 로 한 해시 테이블 구현
#include <stdio.h>
#include <stdlib.h> // 메모리 할당을 위함

struct bucket* hashTable = NULL; 
int BUCKET_SIZE = 10; // 버켓의 총 길이
```

해시테이블은 버켓을 통해 접근하기 때문에 hashTable이라는 이름으로 bucket 배열 주소값을 선언. 버켓의 총 길이는 10.

```c
// 구조체선언
// 노드 구조체 선언
struct node {
    int key; // 해시 함수에 사용될 키
    int value; // key 가 가지고 있는 데이터
    struct node* next; // 다음 노드를 가르키는 포인터
};

// 버켓 구조체 선언
struct bucket{
    struct node* head; // 버켓 가장 앞에 있는 노드의 포인터
    int count; // 버켓에 들어있는 노드의 개수
};
```

노드와 버켓의 구조체 선언.

노드 - 노드에는 key, value가 있고 체이닝이 되었을 때 다음 노드를 가리키는 next 포인터를 멤버로 갖는다.

버켓 - 버켓에 있는 첫번째 노드의 포인터와 해당 버켓에 있는 노드의 개수인 count를 멤버로 갖는다.

---

## 👣 예상 질문 List

### 1. **해시 테이블의 충돌(Collision) 처리 방법에는 어떤 것들이 있나요?**

해시 테이블에서 충돌을 처리하는 방법에는 주로 체이닝과 개방 주소법이 사용된다. 

체이닝은 각 인덱스마다 연결 리스트를 생성하여 충돌하는 데이터를 연결시키는 방식이다. 충돌이 발생하면 해당 인덱스의 연결 리스트에 데이터를 추가하게 된다. 

개방 주소법은 충돌이 발생한 경우 빈 공간을 찾아 데이터를 저장하는 방식이다. 이 외에도 이중 해싱이나 재해싱 등의 충돌 처리 방법이 있다.