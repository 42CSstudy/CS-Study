# 비트마스크

# 1. **비트 연산**

# **NOT, AND, OR, XOR**

<img width="440" alt="스크린샷 2024-02-16 오후 11 38 12" src="https://github.com/42CSstudy/CS-Study/assets/69511382/413705c2-af31-4626-910e-40f9ee1483b2">

not 연산의 경우 자료형에 따라 결과가 달라지는 것을 주의해야 한다.

특히, unsigned와 signed에 따라서 정수로 보여지는 값이 달라진다. (2의 보수 때문)

# **Shift Left, Shift Right**

- `A << B`
    - A를 B비트만큼 왼쪽으로 밀기
    - `A x (2^B)`
    - ex. `3 << 4` = 3 x 2^4 = 3 x 16 = 48
    - 0b11 (10진수로 3) 를 0b110000(10진수로 48)으로 만든 것과 같다. 즉 옆으로 한칸씩 이동 시키기
- `A >> B`
    - A를 B비트만큼 오른쪽으로 밀기
    - `A / (2^B)`
    - ex. `2 >> 4` = 2 / 2^4 = 2 / 16 = 1 / 8

# **2. 비트마스크**

# **개요**

비트마스크는 비트 연산을 이용해 부분집합을 표현하는 것이다.

- 비트마스크를 통해 **집합을 정수로** 나타낼 수 있다.
- 단, 이때 집합에 저장할 수 있는 수의 범위가 정해져 있어야 한다.
- 따라서 보통 **0부터 N-1까지 N개의 정수로 이루어진 집합**을 나태낼 때 사용한다.

**ex)** N = 10일때, s = {1, 3, 4, 5, 9}라는 집합에서 각 수의 존재여부를 나타내면 다음과 같다.

<img width="476" alt="스크린샷 2024-02-16 오후 11 38 20" src="https://github.com/42CSstudy/CS-Study/assets/69511382/3462e472-f742-4b25-9dff-536e71cc271c">

이를 정수로 나타내면, 1000111010(2) = 570와 같다.

# **비트마스크의 장점**

1. 공간을 적게 사용할 수 있다.

- 위 예시에서 집합 s를 표현하는 데에는 1, 3, 4, 5, 9라는 5개의 정수가 필요하지만,
- 비트마스크를 통해 표현하면 570 단 하나의 정수만 사용한다.

2. 연산의 시간복잡도가 `O(1)`로 빠르다. 아래서 살펴보자.

**cf) 비트마스크가 정수라는 것**

이는 장점이 될 수도, 단점이 될 수도 있다.

**장**: 리스트나 배열로 표현할 때 정수는 간편하다.

**단**: 정수는 32bits 혹은 64bits로 범위에 제한이 있어, 수의 범위가 너무 크면 사용할 수 없다.

-> C++의 경우 이러한 단점을 보완하기 위해 bitset이라는 것을 제공한다. (but, 사용할 일 별로 없다고 함)

# **비트마스크의 연산**

집합 S에대해 수 X를 검사, 추가, 삭제, 토글하는 방법

cf) 연산을 수행할 때 연산자 우선 순위 때문에 걱정되면 괄호를 사용하자!

**1. S에 X가 있는지 검사**

= S의 X번째 비트가 1인지 0인지 검사

= X번째 비트만 1로 두고 AND 연산 수행

= **`S & (1 << X)`**

**2. S에 X를 추가**

= S의 X번째 비트를 1로 변경

= X번째 비트만 1로 두고 OR 연산 수행

= **`S | (1 << X)`**

**3. S에서 X를 삭제**

= S의 X번째 비트를 0으로 변경

= X번째 비트만 0으로 두고 AND 연산 수행

= **`S & ~(1 << X)`**

**4. S에서 X를 토글**

= S의 X번째 비트가 0이면 1로, 1이면 0으로 변경

= X번째 비트만 1로 두고 XOR 연산 수행

= **`S ^ (1 << X)`**

# **결론**

- 그냥 배열을 사용하는 것이 편리하지만, 비트마스크를 사용하는 이유는 **집합을 배열의 인덱스로 표현할 수 있기 때문**이다.
- **상태 다이나믹을 할 때 자주 사용**하게 된다.
- **적은 갯수를 저장하는 집합에서 사용하는 것이 적합**하다.

# 활용

위에서 비트마스크 연산을 통해 다양한 부분에서 사용할 수 있다. 

예를 들어 특정 조건들을 확인하고 그 조건들에 맞는 플래그를 세우며 해당 조건에 따라 특정 동작을 하고자 할때 비트마스크를 통해 간단하고 유지보수 가능한 코드를 작성할 수 있다.

```jsx
// 체크할 오브젝트를 정의해보자. API 결과나, 유저와 상호작용할 때나, form 형식에서 불러질 수 있다. 
// 아마 사전엔 알 수 없는 값일 것이다.
const myObject = {
  foo1: false,
  foo2: true,
  foo3: false,
  foo4: true
}

// 코드를 더욱 이해하기 쉽게 만들 수 있는 상수를 정의하자.
// 이 상수들은 많은 방법으로 작성될 수 있다.
// 하지만 이 방법이 직관적으로 이해하기 가장 좋은 방법이라고 원작자는 생각했다.
const HAS_FOO1 = 1;       // 0001
const HAS_FOO2 = 1 << 1;  // 0010
const HAS_FOO3 = 1 << 2;  // 0100
const HAS_FOO4 = 1 << 3;  // 1000

// 비트연산 숫자를 만들어라. 아마 use-case에 따라 다르게 만들어질 것이다.
// 하지만 해야 할 일은 같다. 
// 오브젝트 키를 수동으로 체크하고 if문을 사용하여 한 번에 하나씩 속성을 추가하는 것이다.
let myBitNumber = 0;

if (myObject['foo1'] === true)
  myBitNumber = myBitNumber | HAS_FOO1;
  // 합집합의 형태를 띄기 위해 bit연산자인 "|"를 사용한다.

if (myObject['foo2'] === true)
  myBitNumber = myBitNumber | HAS_FOO2;

if (myObject['foo3'] === true)
  myBitNumber = myBitNumber | HAS_FOO3;

if (myObject['foo4'] === true)
  myBitNumber = myBitNumber | HAS_FOO4;

console.log(myBitNumber.toString(2));
// 1010

/*
 * 비트연산 숫자는 이제 "1010"이라는 값을 가진다. 
 * 왜냐하면 두번째 값과 네번째 값이 true이기 때문이다.
 * 이렇게 표현할 수도 있다:
 *
 * | fourth | third | second | first | <= Attribute
 * |    1   |   0   |   1    |   0   | <= True/false
 *
 */
```

이제 테스트 해보자. 속성에 대해 비트연산 숫자를 체크하고 있다면, 체크할 수 있는 상태가 4가지가 있다. 숫자가 **하나의 명확한 속성을 가지고 있든 아니든, 어떤 주어진 속성의 배열을 가지고 있든 아니든, 명시된 속성들만 가지고 있든 아니든** 혹은 **속성의 배열을 전부 가지고 있든 아니든**말이다.

```jsx
// 비트 숫자가 하나의 소속성만 가지고 있는지 테스트해보자. 
// &는 두 숫자 사이의 교집합을 보증한다.
if (myBitNumber & HAS_FOO1) {
  // False, 이 예제에서는 False이다.
}
if (myBitNumber & HAS_FOO2) {
  // True!
}

// Test whether your bit number has ANY of the specified attributes
if (myBitNumber & (HAS_FOO1 | HAS_FOO2)) {
  // True! (역자 주: 1010 & 0011 의 결과로 0010이 나와서 true이다.)
}
if (myBitNumber & (HAS_FOO1 | HAS_FOO3)) {
  // False
}

// 오직 명시된 속성만을 가지고 있는지 테스트해보자.
if (myBitNumber == (HAS_FOO2 | HAS_FOO4)) {
  // True
}
if (myBitNumber == (HAS_FOO2 | HAS_FOO3 | HAS_FOO4)) {
  // False
}

// 모든 주어진 속성을 포함하는지 확인해보자.
// 살짝 헷갈릴 수 있다. 속성의 합집합은 혼자서 `myBitNumber`를 대체할 수 없다. 
// 다만, `myBitNumber` 가 가지지 못한 비트를 가지고 있다.
if (myBitNumber == (myBitNumber | (HAS_FOO2 | HAS_FOO4))) {
  // True
}
if (myBitNumber == (myBitNumber | (HAS_FOO2 | HAS_FOO3 | HAS_FOO4))) {
  // False
}
```

앞의 소스는 여러 true/false 속성을 효율적으로 저장하고 비교하기 위해 비트연산자들을 활용한 함수의 예제이다. 꽤 읽기 쉽고, 이해하기 쉬우며 업데이트하고 유지보수하기 간단하다. 그리고 하나의 문장을 수정할 필요가 있을 때 또는 또다른 속성을 추가할 필요가 있을 때 사용할 수 있다.