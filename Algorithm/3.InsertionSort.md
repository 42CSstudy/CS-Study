안전 정렬 : 동일한 값에 기존 순서가 유지 (버블, 삽입)

불안정 정렬 : 동일한 값에 기존 순서가 유지X (선택,퀵)

### 삽입정렬

---

자료 배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교 하여, 자신의 위치를 찾아 삽입함으로써 정렬을 완성하는 알고리즘
매 순서마다 해당 원소를 삽입할 수 있는 위치를 찾아 해당 위치에 넣음

```c++
void insertion_sort(int list[], int n) {
    int i, j, key;

    // 인덱스 0은 이미 정렬된 것으로 볼 수 있다.
    for (i = 1; i < n; i++) {
        key = list[i]; // 현재 삽입될 숫자인 i번째 정수를 key 변수로 복사

        // 현재 정렬된 배열은 i-1까지이므로 i-1번째부터 역순으로 조사한다.
        // j 값은 음수가 아니어야 되고
        // key 값보다 정렬된 배열에 있는 값이 크면 j번째를 j+1번째로 이동
        for (j = i - 1; j >= 0 && list[j] > key; j--) {
            list[j + 1] = list[j]; // 레코드의 오른쪽으로 이동
        }

        list[j + 1] = key;
    }
}

```

#### 장점

안정한 정렬 방법
레코드의 수가 적을 경우 알고리즘 자체가 매우 간단하므로 다른 복잡한 정렬 방법보다 유리할 수 있다.

대부분위 레코드가 이미 정렬되어 있는 경우에 매우 효율적일 수 있다.

#### 단점

비교적 많은 레코드들의 이동을 포함한다.

레코드 수가 많고 레코드 크기가 클 경우에 적합하지 않다.

#### 시간복잡도

최선 : O(n)

최악 = O(n^2)
