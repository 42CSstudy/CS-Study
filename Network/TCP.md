# TCP

### 전송 계층

전송 계층은 송신자, 수신자를 연결하는 통신 서비스를 제공하며 연결 지향 데이터 스트림 지원, 신뢰성, 흐름 제어를 제공할 수 있다.

애플리케이션과 인터넷 계층 사이 데이터가 전달될 때 중계 역할을 한다. 

대표적으로 TCP, UDP 가 있다.

**TCP** : 패킷 사이 순서를 보장하고, 연결 지향 프로토콜을 사용해 연결을 해 신뢰성을 구축한다. 수신 여부를 확인하며 ‘가상 회선 패킷 교환 방식’ 을 사용한다.

**UDP** : 순서를 보장하지 않고, 수신 여부를 확인하지 않으며 단순히 데이터만 주는 ‘데이터그램 패킷 교환 방식’ 을 사용한다.

### 가상 회선 패킷 교환 방식

각 패킷에는 가상 회선 식별자가 포함되며, 모든 패킷을 전송하면 가상 회선이 해제되고 패킷들은 전송 순서대로 도착하는 방식을 말한다.

### 데이터그램 패킷 교환 방식

패킷이 독립적으로 이동하며, 최적의 경로를 선택해 간다. 

하나의 메시지에서 분할된 여러 패킷은 서로 다른 경로로 전송 될 수 있으며 도착한 순서가 다를 수 있는 방식을 뜻한다.

<img width="619" alt="%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-03-03_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_10 59 48" src="https://github.com/42CSstudy/CS-Study/assets/87696004/831f436a-cc52-43d5-9e93-2a37a1c09992">


### TCP 연결 성립 과정

TCP 는 신뢰성 확보를 할 때  3-way handshake 라는 작업을 통해 진행한다.

<img width="749" alt="%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-03-03_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_11 01 13" src="https://github.com/42CSstudy/CS-Study/assets/87696004/e4323060-d1de-4c99-ac85-add61c66f186">


1. syn 단계 : 클라이언트는 서버에 클라이언트의 ISN 을 담아 SYN 을 보낸다. ISN 은 새로운 TCP 연결의 첫 번째 패킷에 할당된 임의의 시퀀스 번호를 말하며, 이는 장치마다 다를 수 있다.
2. syn + ack 단계 : 서버는 클라이언트의 SYN 을 수신하고 서버의 ISN 을 보내며 승인번호로 클라이언트의 ISN + 1 을 보낸다.
3. ack 단계 : 클라이언트는 서버의 ISN + 1 한 값인 승인번호를 담아 ACK 를 서버에 보낸다.

syn : SYNchronization . 연결 요청 플래그

ack : ACKnowlegement . 응답 플래그

이 3 way handshake 과정 이후 신뢰성이 구축되고 데이터 전송을 시작한다.

TCP 는 이 과정이 있기 때문에 신뢰성이 있는 계층이라고 하고,

UDP 는 이 과정이 없기 때문에 신뢰성이 없는 계층이라고 한다.

### TCP 연결 해제 과정

TCP 가 연결을 해제 할 때는 4 way handshake 과정이 발생함.

<img width="935" alt="%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-03-03_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_11 26 11" src="https://github.com/42CSstudy/CS-Study/assets/87696004/31e31387-bff4-4705-b9ea-aa3f6c03d62e">

1. 클라이언트가 연결을 닫고자 할 때 FIN 으로 설정된 세그먼트를 전송한다. 이후 클라이언트는 FIN_WAIT_1 상태에 들어가고 서버의 응답을 기다린다.
2. 서버는 클라이언트로 ACK 신호를 보낸다. CLOSE_WAIT 상태에 들어간다. 클라이언트가 세그먼트를 받으면 FIN_WAIT_2 상태가 된다.
3. 서버는 ACK 를 보내고 일정 시간 후 클라이언트에 FIN 세그먼트를 보낸다.
4. 클라이언트는 TIME_WAIT 상태가 되고 다시 서버로 ACK 를 보내어 서버는 CLOSED 상태가 된다. 이후 클라이언트는 어느 정도 시간을 대기한 후 연결이 닫히고 클라이언트와 서버의 모든 자원의 연결이 해제된다.

왜 클라이언트는 바로 연결을 닫지 않고 TIME-WAIT 상태가 될까? (일정 시간 후 연결을 닫는것)

1. 지연 패킷이 발생한 경우 이를 받기 위해서
2. 두 장치가 연결이 닫혔는지 확인하기 위함.