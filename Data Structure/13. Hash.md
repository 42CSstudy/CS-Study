### 해시 

- 연결리스트와 트리구조에서 검색시간이 O(n)과 O(log n)이 걸렸다. 그러나 컴퓨터 공학자들은 이 시간을 더 단축시켜서 O(1)에 가깝게 만들기를 원했다.

- 위를 가능하게 해주는 구조 중 하나가 바로 해시 테이블이다.

- 해시테이블은 연결리스트를 원소로 가지는 배열이다.

- 이름표를 바구니에 담는다고 가정하자. 단순히 바구니 하나에 여러 이름표를 담으면 사람들이 찾는 데 오랜 시간이 걸릴 것이다.

- 그렇다면 바구니를 여러개로 한다면 어떨까. 이 때 바구니를 무슨 기준으로 나누는 것이 좋을까.

- 이 때의 기준이 해시 함수이다. 이름표이므로 해시함수를 이름의 가장 첫 글자로 시도해보자. 알파벳이라면 총 16개의 포인터들이 생기고, 그 알파벳은 각각 연결리스트를 가리키게 된다.

![image (3)](https://github.com/42CSstudy/CS-Study/assets/69511382/31e811da-a746-4c23-9ec8-9a7789183e0b)

- 위와 같은 구조를 사용해서 검색시간을 비약적으로 줄일 수 있다.

- 즉 이론상 해시함수가 이상적이라면, 각 바구니에는 단 하나의 값만 담길 것이고, 검색시간은 O(1)이 된다.

- 그러나 최악의 해시함수를 사용해서 단 하나의 바구니에 모든 값이 담기면 O(n)이겠지만 일반적으로 최대한 많은 바구니를 만들도록 해시함수를 사용하므로 그럴일은 없다고 본다.

- 해시 함수

그렇다면 **해시 함수**(Hash Function)란?

**임의의 길이를 갖는 임의의 데이터**를

**고정된 길이의 데이터**(해시 값)로 매핑하는 함수를 말한다.

아래 그림으로 한눈에 이해 가능할 듯싶다.

### **해시함수 특성**

해시 함수는 보통 그리 복잡하지 않은 알고리즘으로 구현된다.

따라서 상대적으로 CPU, 메모리 등의

시스템 자원을 덜 소모하는 특성이 있다.

그리고 같은 입력값에 대해서는 값은 출력 값이 보장되고,

이 출력 값은 가능한 한 고른 범위에 균일하게 분포하는 특성이 있다.

특수 목적용으로 해시값을 생성하는 원본과 별도의 값을 입력받아서

같은 입력에 대해 다른 출력 값을 가지게 하는 해시 함수도 존재한다.

ex) 'abc'(입력값) + '!@#'(별도의 값) -> '1234'(해시 값)